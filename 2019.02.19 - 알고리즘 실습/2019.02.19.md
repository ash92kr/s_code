# 2019.02.19





### 1. 복습

계산기 - 중위 표기법을 후위 표기법으로 바꾼 다음에 후위 표기법을 계산한다(모두 stack 사용)

토큰 = 더 이상 나눌 수 없는 단위, 피연산자(문자열)은 순서대로 출력해야 한다, 연산자를 스택에 넣는다

왼쪽 연산자는 무조건 스택에 넣되, 우선순위가 낮은 것을 만날 때까지 pop하고 push한다

오른쪽 연산자를 만나면 해당 왼쪽 연산자를 만날 때까지 pop한다

스택에서 빼낸 경우, 먼저 만난 피연산자를 우측에, 그 다음 피연산자를 좌측에 넣고 결과값을 다시 스택에 넣는다



미로 찾기 : 델타 검색과 백트래킹 이용

백트래킹 : dfs(완전검색을 재귀로 실시) + 가지치기(재귀를 시작할 때 or 재귀함수를 부르기 전) 

-> 부분집합(2^n), 순열(n!), 중복순열, 조합, 중복조합에 사용 가능(문제를 정확하게 읽을 줄 알아야 한다)



다시 한 번 적지만 문제를 정확하게 분석하고 이해해야 한다(요구사항 분석 -> 설계 -> 구현 -> 테스트 -> 유지보수)

요구사항 분석 및 설계를 잘해야 개발자고 구현만 잘하는 사람은 코더다

IM의 문제 수준은 회문 ~ 미로찾기 수준(for문을 얼마나 잘 쓰는가?)



참고 : 가지치기의 smart 버전 - 분기한정

참고 : 완전검색 -> 가지치기 -> DP(반복)



일반 백트래킹 : promising하면 출력하고 promising하지 않으면 return할 것

모든 경우의 수 나타내는 상태공간트리 - 그림에서는 왼쪽으로 가면 1, 오른쪽으로 가면 0, 한 차원 내려가면 깊이가 1이 됨(시작점을 0으로 가정하고 시작할 것)



```
c[MAXCANDIDATES] = 최대 후보의 개수로 리스트를 만듦(가능한 경우의 수로 리스트를 만듦)

ncands = 후보자의 수(가능한 경우의 수)

깊이 k가 원하는 수준까지 온 경우 원하는 행동을 함

그렇지 않으면 k를 먼저 더한 다음에 작업 실시 = 0번 k를 사용하지 않는다(k=0을 사용하고 싶으면 backtrack(a, k+1, input이라고 입력))

mack_candidates : 후보 만들기 함수(틀을 이용해 backtracking 사용) = TRUE, FALSE만 집어넣으면 된다(개수는 총 2개) -> 매번 반복할 때마다 새롭게 틀이 만들어짐

True를 먼저 넣었으므로 왼쪽으로 가서 1(True)을 넣음

최대 깊이와 k가 같으면 원래 값을 출력할 것

한 단계 아래로 돌아가서 i=1 (False)를 a에 넣고 다시 깊이 들어갈지 말지 결정함
```



```
순열 - 가짓수가 많아지나 뒤로 갈수록 넣을 수 있는 경우의 수가 줄어든다

앞에 사용한 숫자는 뒤에 사용할 수 없으므로 visited를 만들어 사용

in_perm[MAX] 리스트를 만들어 모두 False를 넣음

for i in range(1, k-1):
	in_perm[a[i]] = True  # 해당 값이 사용되면 in_perm 리스트의 인덱스에도 1을 넣음
	
ncand = 0
for i in range(1, n):   # 최대 깊이 n까지 실시
	if in_perm[i] == False:   # 사용하지 않은 숫자는
		c[ncands] = i   # c 후보 리스트에 a의 값을 추가하고 사용한 숫자는 pass
		ncands ++
```



* 가지치기

data가 1부터 시작하면 data[k-1]로 변경할 것

```
if sum > 10:
	return   # 최대 깊이까지 가지 않았는데 벌써 sum이 10보다 커지면 None값을 반환하고 넘김
```



* 연습문제 - 자성체끼리는 전혀 반응하지 않음

```
def solve(data, size):
    cnt = 0
    for x in range(size):       # 열우선 순회
        flag = 0   # 준비 상태
        for y in range(size):
            value = data[y][x]
            if flag == 0 and value == 1:    # N극을 찾음
                flag = 1    
            elif flag == 1 and value == 2:  # S극을 찾음
                cnt += 1
                flag = 0
    return cnt


import sys
sys.stdin = open("(1220)Magnetic_input.txt")
T = 10
for tc in range(T):
    N = int(input())
    data = [[0 for _ in range(N)]for _ in range(N)]
    for i in range(N):
        data[i] = list(map(int, input().split()))
	# data = [list(map(int, input().split())) for _ in range(N)]   # 위 2줄을 간략하게

    print(f"#{tc+1} {solve(data, N)}")
```



### 2. 오늘의 실습 4 + 1문제



(1) Forth : 간단한 계산기 문제



(2) 미로 : 미로찾기(재귀 + 스택, 델타 검색)



(3) 토너먼트 카드게임 : 분할정복(재귀와 return값) - 퀵정렬(l과 r이 큰 곳에서만 돈다) return을 받아 계산을 한다 -> 경우의 수는 9가지(결과가 2가지 - 승/패)



(4) 배열 최소합 : 백트래킹(인덱스 값을 순열로 만듦) -> 각 열의 인덱스를 구해 0, 1, 2를 배치한다 -> 그리고 최소값 구함 -> 또는 바깥쪽 행/열에 0을 붙여서 1, 2, 3을 인덱스로 이용한다



(5) 실습문제 : 계산기3 - 중위표기법을 후위표기법으로 바꾸는 이유는 괄호를 없애기 위함













공지사항 : 상반기 일정 3/9, 4/6 모두 응시할 것, 커리큘럼 바뀜, 신분증 제시 및 핸드폰 제출, 책 제출

IM 시험을 통과하면 AD1, AD2 응시 가능(하루 안에 응시 가능), 제출 횟수는 최대 10번 예상

서버에 올려 놓은 다음에 로컬에서 작업할 것(컴퓨터 에러 대비)

IM, AD는 모두 1문제 출제됨











